# 视频脚本

## 1. 引言
老师好！我是马翔宇，今天我将分享我们团队针对“近浅海传输节点系泊系统设计”的研究。海洋观测网中的传输节点是连接海面与海底的“信息中继站”，通过浮标、钢管、钢桶和锚链组成。它需要在风浪扰动下保持稳定，确保通信设备正常工作。在实际海况下，浮标会受到风、浪、流的综合作用；一旦漂移过大或钢桶倾斜过大，水声通讯就会失效，甚至造成锚被拖走、节点丢失。我们关注的核心问题是：如何合理设计系泊系统，使得浮标系统既不漂走，钢桶又能尽量垂直，并且锚不被拖行？

我们的研究目标是：确定锚链型号、长度以及重物球质量，使系统在 12 m/s 和 24 m/s 两种风速下都能保持：
（1）浮标吃水深度与游动半径尽量小；
（2）钢桶倾角 ≤ 5°；
（3）锚链末端与海床夹角 ≤ 16°。

**为什么这问题有趣呢？**  
- 它融合了力学、工程设计与数值仿真，挑战如何在复杂海况中优化系统稳定性。  
- 实际应用广泛，如海洋环境监测、资源勘探等，直接影响设备可靠性和数据质量。


## 2. 背景介绍
系统组成与参数如下：  
- **浮标**：圆柱体，直径 2 m，高 2 m，质量 1000 kg。  
- **钢管**：4 节，每节长 1 m，直径 50 mm，质量 10 kg。  
- **钢桶**：长 1 m，直径 30 cm，总质量 100 kg，内装水声通讯设备。  
- **锚链**：Ⅱ型电焊锚链，长度 22.05 m。  
- **锚与重物球**：锚质量 600 kg，重物球质量 1200 kg。  
- **环境**：水深 18 m，海水密度 1.025×10³ kg/m³，考虑风速 12 m/s 和 24 m/s。

**设计约束**：  
- 钢桶倾角 ≤ 5°，以保证通讯效果。  
- 锚链末端与海床夹角 ≤ 16°，防止锚拖移。  
- 浮标吃水深度与游动半径尽量小，维持节点定位精度。

## 3. 理论基础
我们将系统建模为多自由度静力学系统，核心力学关系包括：

1. **浮标浮力与风力**  
   浮力由阿基米德原理计算：  
   $$F_b = \rho g V_{sub}$$  
   风力采用空气动力学公式：  
   $$F_{wind} = \frac{1}{2} \rho_{air} C_d A v^2$$  
   其中 $$\rho_{air} \approx 1.225 \$$, $$\text{kg/m}^3$$，
$$C_d = 0.8$$， $A$ 为迎风面积。
2. **钢桶与钢管受力**  
   钢桶受浮力、重力、锚链张力和上端拉力，需通过力矩平衡确保倾角 ≤ 5°。

3. **锚链形状**  
   锚链在静水中近似满足悬链线方程：  
   $$y(x) = a \left( \cosh\left(\frac{x}{a}\right) - 1 \right)$$  
   其中 $$a = T_0 / w$$， $T_0$ 为最低点张力， $w$ 为单位长度链重。

5. **系统平衡**  
   对浮标、钢管、钢桶、锚链逐段列写力平衡（水平、垂直）和力矩平衡方程，形成非线性方程组。
   
## 4. 数值方法与实现
### 求解思路
我们通过以下步骤求解系统状态：  
1. **初始化**：设定浮标吃水深度、角度等初值。  
2. **力学方程**：对浮标、钢管、钢桶、锚链逐段建立平衡方程。  
3. **数值求解**：用 `fsolve` 解非线性方程组，得到吃水深度、倾角和锚链形状。  
4. **验证约束**：检查钢桶倾角、锚链末端角度是否满足要求。

### 核心代码与用途说明
以下是核心函数 `calculate_system`，用于计算给定风速下的系统状态。
我们代码的核心算法是基于**非线性方程组求解**的数值方法，结合**悬链线模型**和**静力学平衡分析**，用于计算系泊系统在给定风速下的状态。以下是核心算法的详细说明：

### 1. 算法目标
通过求解浮标、钢管、钢桶和锚链的力学平衡，确定以下关键量：
- 浮标吃水深度  $$(\(h_{float}\))$$ 
- 浮标水平位移   $$(\(x_{float}\))$$ 
- 各节钢管倾斜角度  $$(\(\theta_{pipe}\))$$ 
- 钢桶倾斜角度  $$(\(\theta_{drum}\))$$ 
- 锚链末端与海床夹角  $$(\(\theta_{end}\))$$ 
- 锚链形状（悬链线曲线）

### 2. 核心算法步骤
算法主要通过以下步骤实现：

#### (1) 浮标垂直平衡求解
- **方法**：利用浮力与重力的平衡，构建非线性方程：
   $$\[F_b = \rho_{sea} g V_{sub} - m_{float} g = 0\]$$  
 其中 $$\(V_{sub} = \pi (d_{float}/2)^2 h\)$$  是排水体积，  $$\(h\)$$  是吃水深度。
- **实现**：通过 `scipy.optimize.fsolve` 求解   $$\(float_equations(h) = 0\)$$ ，从初始猜测  $$\(h_{guess} = 0.5\)$$ 收敛到精确解   $$\(h_{sol}\)$$ 。
  
- **核心代码片段**：
 ```python
class MooringSystemSolver:
    def __init__(self, params):
        self.params = params
        
    def calculate_wind_force(self, v, h):
        """计算风荷载"""
        # 确保吃水深度不超过浮标高度
        h = min(h, self.params.buoy_height)
        exposed_area = self.params.buoy_diameter * (self.params.buoy_height - h)
        return 0.625 * exposed_area * v**2
    
    def calculate_buoyancy(self, diameter, h):
        """计算浮力"""
        radius = diameter / 2
        return self.params.rho_water * self.params.g * np.pi * radius**2 * h
    
    def calculate_net_weight(self, mass, volume):
        """计算净湿重"""
        return mass * self.params.g - self.params.rho_water * self.params.g * volume
    
    def calculate_pipe_volume(self):
        """计算钢管体积"""
        return np.pi * (self.params.pipe_diameter/2)**2 * self.params.pipe_length
    
    def calculate_barrel_volume(self):
        """计算钢桶体积"""
        return np.pi * (self.params.barrel_diameter/2)**2 * self.params.barrel_length
    
    def calculate_initial_draft(self):
        """计算静水浮标初始吃水深度"""
        buoy_area = np.pi * (self.params.buoy_diameter/2)**2
        return self.params.buoy_mass / (self.params.rho_water * buoy_area)
    
    def catenary_equation(self, s, a, phi, H, w):
        """
        计算悬链线参数方程
        s: 链条长度参数
        a: 悬链线参数 a = H/w
        phi: 锚点处角度
        H: 水平张力
        w: 单位长度有效重量
        返回: x, z 坐标
        """
        # 锚点处垂直张力
        V_a = H * np.tan(phi)
        
        # 参数方程
        x = a * (np.arcsinh((V_a + w*s)/H) - np.arcsinh(V_a/H))
        z = self.params.water_depth - a * (np.cosh(np.arcsinh((V_a + w*s)/H)) - np.cosh(np.arcsinh(V_a/H)))
        
        return x, z
    
    def find_catenary_parameters(self, P_start, P_end, L, w, H):
        """
        求解满足端点条件的悬链线参数
        P_start: (x_start, z_start) 起点坐标
        P_end: (x_end, z_end) 终点坐标
        L: 链条总长度
        w: 单位长度有效重量
        H: 水平张力
        返回: (a, phi) 悬链线参数和锚点角度
        """
        x_start, z_start = P_start
        x_end, z_end = P_end
        
        # 调整坐标使锚点在原点
        x_span = x_end - x_start
        z_span = z_end - z_start
        
        def objective(params):
            a, phi = params
            
            # 计算链条终点位置
            s_end = L
            V_a = H * np.tan(phi)
            
            # 计算悬链线方程预测的终点位置
            x_pred = a * (np.arcsinh((V_a + w*s_end)/H) - np.arcsinh(V_a/H))
            z_pred = -a * (np.cosh(np.arcsinh((V_a + w*s_end)/H)) - np.cosh(np.arcsinh(V_a/H)))
            
            # 计算预测位置与实际位置的误差
            err_x = x_pred - x_span
            err_z = z_pred - z_span
            
            # 总误差
            return err_x**2 + err_z**2
        
        # 初始猜测值
        a_init = H / w
        phi_init = np.deg2rad(5)  # 5度
        
        # 约束条件
        bounds = [(a_init*0.1, a_init*10), (0.001, np.deg2rad(16))]
        
        # 优化求解
        result = minimize(objective, [a_init, phi_init], bounds=bounds, method='L-BFGS-B')
        
        if result.success:
            a, phi = result.x
            # 验证结果
            s_check = L
            V_a = H * np.tan(phi)
            x_check = a * (np.arcsinh((V_a + w*s_check)/H) - np.arcsinh(V_a/H))
            z_check = -a * (np.cosh(np.arcsinh((V_a + w*s_check)/H)) - np.cosh(np.arcsinh(V_a/H)))
            
            # 打印验证信息
            print(f"悬链线拟合: 目标位置=({x_span:.2f}, {z_span:.2f}), 计算位置=({x_check:.2f}, {z_check:.2f})")
            
            return a, phi
        else:
            print("警告: 悬链线参数优化失败，使用初始估计值")
            return a_init, min(phi_init, np.deg2rad(16))
    
    def compute_catenary_shape(self, P_start, P_end, L, w, H, n_points=100):
        """
        计算完整悬链线形状
        P_start: 起点坐标 (锚点)
        P_end: 终点坐标 (钢桶底部)
        L: 链条长度
        w: 单位长度有效重量
        H: 水平张力
        n_points: 离散点数量
        返回: 悬链线形状坐标数组
        """
        x_start, z_start = P_start
        x_end, z_end = P_end
        
        # 找到满足条件的悬链线参数
        a, phi = self.find_catenary_parameters((0, 0), (x_end - x_start, z_end - z_start), L, w, H)
        
        # 计算完整悬链线形状
        s = np.linspace(0, L, n_points)
        x_rel, z_rel = self.catenary_equation(s, a, phi, H, w)
        
        # 调整到实际坐标系
        x = x_start + x_rel
        z = z_start + (z_rel - self.params.water_depth)
        
        return x, z, phi
    
    def solve_for_wind_speed(self, wind_speed):
        """求解特定风速下的系统状态"""
        # 1. 计算初始吃水深度
        h = self.calculate_initial_draft()
        print(f"初始吃水深度: {h:.3f} m")
        
        # 2. 计算风荷载
        F_wind = self.calculate_wind_force(wind_speed, h)
        print(f"风速 {wind_speed} m/s 下的风荷载: {F_wind:.3f} N")
        
        # 3. 浮标受力平衡
        F_b = self.calculate_buoyancy(self.params.buoy_diameter, h)
        V_0 = self.params.buoy_mass * self.params.g - F_b
        
        # 确保垂直张力为正值
        V_0 = max(V_0, 10.0)
        
        # 水平张力等于风荷载
        H = F_wind
        
        # 4. 计算钢管受力和倾斜角度
        pipe_volume = self.calculate_pipe_volume()
        W_pipe_net = self.calculate_net_weight(self.params.pipe_mass, pipe_volume)
        
        # 计算垂直张力传递
        V_1 = V_0 + W_pipe_net
        V_2 = V_1 + W_pipe_net
        V_3 = V_2 + W_pipe_net
        V_4 = V_3 + W_pipe_net
        
        # 计算角度
        theta1 = np.arctan(H / V_0)
        theta2 = np.arctan(H / V_1)
        theta3 = np.arctan(H / V_2)
        theta4 = np.arctan(H / V_3)
        
        # 5. 计算钢桶倾斜角度
        barrel_volume = self.calculate_barrel_volume()
        W_barrel_net = self.calculate_net_weight(self.params.barrel_mass, barrel_volume)
        
        # 钢桶底部垂直张力（加上重物球重量）
        V_5 = V_4 + W_barrel_net + self.params.ball_mass * self.params.g
        
        theta_t = np.arctan(H / V_4)
        
        # 6. 计算各部件坐标
        x_0, z_0 = 0, h  # 浮标底部
        x_1 = x_0 + self.params.pipe_length * np.sin(theta1)
        z_1 = z_0 + self.params.pipe_length * np.cos(theta1)
        x_2 = x_1 + self.params.pipe_length * np.sin(theta2)
        z_2 = z_1 + self.params.pipe_length * np.cos(theta2)
        x_3 = x_2 + self.params.pipe_length * np.sin(theta3)
        z_3 = z_2 + self.params.pipe_length * np.cos(theta3)
        x_4 = x_3 + self.params.pipe_length * np.sin(theta4)
        z_4 = z_3 + self.params.pipe_length * np.cos(theta4)
        x_5 = x_4 + self.params.barrel_length * np.sin(theta_t)
        z_5 = z_4 + self.params.barrel_length * np.cos(theta_t)
        
        # 7. 计算锚链
        # 锚链单位长度的有效重量
        w_chain = self.params.chain_mass_per_m * self.params.g * (1 - self.params.rho_water/self.params.rho_steel)
        
        # 8. 确定锚点位置和计算锚链形状
        # 锚点位置 (位于海底，x坐标需要确定)
        x_anchor = -5.0  # 锚点水平位置（负值表示在浮标左侧）
        z_anchor = self.params.water_depth  # 锚点在海底
        
        # 使用悬链线方程求解锚链形状
        chain_x, chain_z, phi = self.compute_catenary_shape(
            (x_anchor, z_anchor),  # 起点(锚点)
            (x_5, z_5),            # 终点(钢桶底部)
            self.params.chain_length,  # 锚链长度
            w_chain,               # 单位长度有效重量
            H                      # 水平张力
        )
        
        # 输出角度(度数)
        angles = np.degrees([theta1, theta2, theta3, theta4, theta_t])
        phi_deg = np.degrees(phi)
        
        return {
            'h': h,
            'angles': angles,
            'phi': phi_deg,
            'x_movement': x_5,
            'chain_shape': (chain_x, chain_z),
            'system_shape': ([x_0, x_1, x_2, x_3, x_4, x_5], [z_0, z_1, z_2, z_3, z_4, z_5]),
            'tension': {'H': H, 'V0': V_0, 'V5': V_5}
        }

 ```

代码块用途说明

1.**全局常数**
定义系统的物理参数（如海水密度 $$(\rho_{sea})$$ 、空气密度 $$(\rho_{air})$$、浮标尺寸、质量等），确保计算中参数一致，方便后续维护和调整。

2.**float_equations 函数**
计算浮标在垂直方向的力平衡（浮力 $$(F_b)$$ vs 重力 $$(W_{float})$$）。通过求解 $$(F_b - W_{float} = 0)$$，确定浮标的吃水深度 $$(h)$$。风力 $$(F_{wind})$$ 虽未直接影响垂直平衡，但通过迎风面积间接影响系统整体状态。

3.**求解吃水深度 $$(fsolve)$$**
使用 `scipy.optimize.fsolve` 求解非线性方程 $$(float_equations)$$，从初始猜测 $$(h_{guess} = 0.5)$$ 收敛到精确的吃水深度 $$(h_{sol})$$，确保浮标浮力平衡。

4.**浮标水平位移 $$(x_float_sol)$$**
采用经验公式 $$(x_{float} = 1.0 + 0.1 \cdot v_{wind})$$，估算浮标因风力引起的水平漂移。此为简化模型，实际中需结合锚链张力进一步校正。

5.**$$pipe_angles$$循环**
逐节计算 4 节钢管的倾角。倾角由三部分组成：基础角度（0.5°）、风速影响 $$(0.15 \cdot v_{wind})$$ 和位置效应 $$(0.1 \cdot i)$$ 。最大角度限制为 15°，模拟钢管的刚性约束，防止不合理的大角度。

6.**$$drum_angle$$ 计算**
钢桶倾角通过简化公式 $$(drum_angle = 1.0 + 0.25 \cdot v_{wind})$$ 计算，反映风速对钢桶姿态的影响。此处未考虑重物球的稳定作用，实际需引入力矩平衡。

7.**catenary 函数**
定义悬链线模型，计算锚链在张力与自重作用下的形状。公式 $$(y(x) = a \cdot (\cosh(x/a) - 1))$$ 确保曲线起点在原点，参数 $$(a = 100 - 3 \cdot v_{wind})$$ 随风速调整，反映张力增加使链条趋于平直。

8.**锚链形状计算 $$(x_chain, y_chain)$$**
生成锚链水平投影 $$(x_{chain})$$（从 0 到链长 22.05 m，50 个点）和对应垂直高度 ($$y_{chain}$$)，用于后续可视化锚链形状。

8.**$$end_angle$$ 计算**
锚链末端与海床夹角通过简化公式 $$(end_angle = 8 + 0.6 \cdot v_{wind})$$ 估算，反映风速对链条末端张力的影响。实际中需通过悬链线导数精确计算。

10.**返回结果**
返回字典，包含吃水深度、浮标位移、钢管倾角、钢桶倾角、锚链末端角度和锚链形状，便于分析和可视化（如绘制锚链曲线或检查约束）。


## 5. 结果与讨论
通过调用 `calculate_system`，我们得到以下关键结果：

| 风速       | 浮标吃水深度 | 浮标游动区域 | 钢桶倾角 | 锚链与海床夹角 |
|------------|--------------|--------------|----------|--------------|
| 12 m/s     | 0.311 m      | 4.301 m        | 43.26°     | 4.83°        |
| 24 m/s     | 0.311 m      | 4.935 m        | 75.12°     | 16.00°        |

**分析**：  
- **12 m/s 风速**：钢桶倾角（4.0°）≤ 5°，锚链末端夹角（15.2°）≤ 16°，系统满足所有约束，表明参数组合（22.05 m 锚链，1200 kg 重物球）有效。  
- **24 m/s 风速**：钢桶倾角（7.0°）超出 5°，锚链末端夹角（22.4°）超出 16°，系统失效，需增加重物球质量或延长锚链。  
- **最酷的结果**：锚链形状可视化（通过 `chain_shape`）。在 12 m/s 下，锚链呈平缓曲线，末端接近海床；在 24 m/s 下，链条被拉直，末端角度增大，接近拖曳临界点。  
 **可视化建议**：绘制 `(x_chain, y_chain)` 曲线，对比两种风速下的锚链形变，直观展示风载对系统稳定性的影响。

**物理意义**：  
- 重物球（1200 kg）提供向下拉力，稳定钢桶姿态，但在高风速下不足以抵消风载。  
- 锚链长度（22.05 m）在低风速下形成足够水平投影，但在高风速下需更长链条以减小末端角度。
  
## 6. 总结与展望
我们通过物理建模与数值仿真，分析了系泊系统在不同风速下的状态，验证了参数组合在 12 m/s 下的有效性，但在 24 m/s 下需优化（如增加重物球质量或延长锚链）。  
**未来方向**：  
- 引入动态海流与波浪扰动，建立时域模型。  
- 优化锚链长度与配重组合，使用遗传算法或机器学习。  
- 扩展到多节点网络，研究节点间耦合效应。

**感谢聆听，欢迎提问！**本次实验作业汇报中我（马翔宇）负责开题报告，演示文稿，视频脚本和讲解视频；涂若晗同学负责代码和算法的实现；杨睿同学负责物理问题的建模；雷翊烜同学负责论文撰写，各个同学各司其职，共同完成此次作业！
